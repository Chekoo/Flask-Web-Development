## 初始化

所有的Flask都必须创建一个程序实例，是Flask类的对象
Web服务器使用一种名为Web服务器网关接口(Web Server Gateway Interface, WSGI)的协议，
把接收自客户端的所有请求都转交给这个对象处理。

from flask import Flask
app = Flask(__name__)

Flask类的构造函数只有一个必须指定的参数，即程序主模块或包的名字，在大多数程序中，Python的__name__变量就是所需的值
将构造函数的name函数传给Flask程序，Flask用这个参数决定程序的根目录，以便稍后能找到相对程序根目录的资源文件位置

客户端传递请求给服务器，服务器把请求发送给Flask程序实例，实例保存了一个URL到Python函数的映射关系。
处理URL和函数之间关系的程序称为路由。

    @app.route('/')
        def index():
        return '<h1>Hello world</h1>'

修饰器可以用不同的方式修改函数的行为。惯用方法是用修饰器把函数注册为事件的处理程序
函数的返回值称为响应，是客户端接到的内容。

例如index这样的函数称为视图函数，它返回的响应可以是包含HTML的简单字符串，也可以是复杂的表单。

路由也可以使用动态名字：

    @app.route('/user/<name>')
        def user(name):
        return '<h1>Hello, %s</h1>' % name
"<>"内为动态部分，任何能匹配静态部分的URL都会映射到这个路由上。
调用视图函数时，Flask会将动态部分作为参数传入函数。
动态部分也可使用类型定义，int、float、path，path类型也是字符串，但不把斜线视为分隔符，而将其作为动态片段的一部分
/user/<int:id>只会匹配动态片段id为整数的URL

## 请求-响应循环

###### 程序和请求上下文
Flask从客户端收到请求时，要让视图函数能访问一些对象，这样才能处理请求。

__请求对象__ 是一个很好的例子，封装了客户端发送的HTTP请求。

Flask用 __上下文__ 临时把某些对象变为全局可访问。

__线程__ 可单独管理的最小指令集

Flask中有两种上下文
1. 程序上下文
current_app:    当前激活程序的程序实例
g:    处理请求时用作临时存储的对象，每次请求都会重设这个变量。
2. 请求上下文
request:        请求对象，封装了客户端发出的HTTP请求的内容
session:        用户会话，用于存储请求之间需要"记住"的值的词典

Flask在分发请求之前激活(或推送)程序和请求上下文，请求处理完成后再将其删除

###### 请求调度
程序收到请求时，要找到处理该请求的视图函数，Flask会在程序的URL映射中查找请求的URL。
URL映射是URL和视图函数之间的对应关系，app.route或app.add_url_rule()生成映射。

URL映射中的HEAD、Options、GET是请求方法。

###### 请求钩子
有时在处理请求之前或之后执行代码会很有用。注册通用函数，注册的函数可以在请求被分发到视图函数之前或之后调用。
请求钩子使用修饰器实现。
before_first_request:  注册一个函数，在处理第一个请求之前运行。
before_request:   注册一个函数，在每次请求之前运行。
after_request:   注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行
teardown_request:   注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。
请求钩子函数和视图函数之间共享数据一般使用上下文全局便来能g。

###### 响应
Flask调用视图函数后，会将其返回值作为响应的内容，大多数情况下，响应就是简单的字符串，作为HTML页面回送客户端。
HTTP协议还需要一个状态吗，Flask默认为200，这个代码表明请求已经被成功处理
redirect()，用于生成重定向响应。
abort()生成用于处理错误的响应。abort不会吧控制权还给调用它的函数，而是抛出异常把控制权给Web服务器。

###### Flask扩展

Flask-Scrit为Flask添加了一个命令行解析器。把程序实例作为参数传给构造函数，初始化主类的实例，
服务器由manager.run()启动，启动后就能解析命令行。

## 初始化

所有的Flask都必须创建一个程序实例，是Flask类的对象
Web服务器使用一种名为Web服务器网关接口(Web Server Gateway Interface, WSGI)的协议，
把接收自客户端的所有请求都转交给这个对象处理。

from flask import Flask
app = Flask(__name__)

Flask类的构造函数只有一个必须指定的参数，即程序主模块或包的名字，在大多数程序中，Python的__name__变量就是所需的值
将构造函数的name函数传给Flask程序，Flask用这个参数决定程序的根目录，以便稍后能找到相对程序根目录的资源文件位置

客户端传递请求给服务器，服务器把请求发送给Flask程序实例，实例保存了一个URL到Python函数的映射关系。
处理URL和函数之间关系的程序称为路由。

@app.route('/')
def index():
    return '<h1>Hello world</h1>

修饰器可以用不同的方式修改函数的行为。惯用方法是用修饰器把函数注册为事件的处理程序
函数的返回值称为响应，是客户端接到的内容。

例如index这样的函数称为视图函数，它返回的响应可以是包含HTML的简单字符串，也可以是复杂的表单。

路由也可以使用动态名字：
@app.route('/user/<name>')
def user(name):
    return '<h1>Hello, %s</h1>' % name
"<>"内为动态部分，任何能匹配静态部分的URL都会映射到这个路由上。
调用视图函数时，Flask会将动态部分作为参数传入函数。
动态部分也可使用类型定义，int、float、path，path类型也是字符串，但不把斜线视为分隔符，而将其作为动态片段的一部分
/user/<int:id>只会匹配动态片段id为整数的URL

## 请求-响应循环

###### 程序和请求上下文
Flask从客户端收到请求时，要让视图函数能访问一些对象，这样才能处理请求。

__请求对象__ 是一个很好的例子，封装了客户端发送的HTTP请求。

Flask用 __上下文__ 临时把某些对象变为全局可访问。

__线程__ 可单独管理的最小指令集

Flask中有两种上下文
1. 程序上下文
current_app:    当前激活程序的程序实例
g:    处理请求时用作临时存储的对象，每次请求都会重设这个变量。
2. 请求上下文
request:        请求对象，封装了客户端发出的HTTP请求的内容
session:        用户会话，用于存储请求之间需要"记住"的值的词典

Flask在分发请求之前激活(或推送)程序和请求上下文，请求处理完成后再将其删除

###### 请求调度
程序收到请求时，要找到处理该请求的视图函数，Flask会在程序的URL映射中查找请求的URL。
URL映射是URL和视图函数之间的对应关系，app.route或app.add_url_rule()生成映射。

URL映射中的HEAD、Options、GET是请求方法。